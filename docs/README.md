# Native VRF Integration Guide

## Overview

The **Native Verifiable Random Function (VRF)** provides a decentralized way to generate random numbers that are cryptographically secure and verifiable on-chain. This guide will walk you through how to use the **Native VRF** in your smart contract to request and utilize random numbers.

## VRF Smart Contract Addresses

To interact with the Native VRF, you need to use the contract address deployed on your blockchain network. You will use these addresses in your contract to request random numbers.

- **LaChain VRF Contract Address**: `0xE2B50Cef64d66b503Ac269980f39550590F5b23C`
- **LaTestnet VRF Contract Address**: `0x694dBD550cE26023ED931993303044fFB4B57879`

Verify the contract addresses and transactions on the blockchain explorer:
- [**LaChain Explorer URL**](https://explorer.lachain.network/address/0xE2B50Cef64d66b503Ac269980f39550590F5b23C)
- [**LaTestnet Explorer URL**](https://testexplorer.lachain.network/address/0x694dBD550cE26023ED931993303044fFB4B57879)

## 1. Importing Native VRF into Your Contract

You will need to import the `INativeVRF` interface to interact with the Native VRF. This interface exposes the necessary functions to request random numbers and retrieve the results.

Example:

```solidity
// SPDX-License-Identifier: MIT
pragma solidity 0.8.4;

import "../interfaces/INativeVRF.sol";
```

The INativeVRF interface contains the functions you need to request and fetch random numbers.

## 2. Requesting a Random Number

Once the VRF interface is imported, you can request a random number using the requestRandom function. This function sends a request to the Native VRF contract to generate a random number.

Here's an example of a contract requesting a random number:

```solidity
contract NativeVRFConsumer {

    uint256[] public randomResults;
    uint256[] public requestIds;
    INativeVRF public nativeVRF;

    event RandomGenerated(uint256 indexed index, uint256 indexed requestId);

    constructor(address nativeVRF_) {
        nativeVRF = INativeVRF(nativeVRF_);
    }

    // Function to request a random number
    function generateRandom() external payable {
        uint256[] memory ids = nativeVRF.requestRandom{value: msg.value}(1);
        requestIds.push(ids[0]);

        emit RandomGenerated(requestIds.length, ids[0]);
    }
}
```

### Notes:

- generateRandom(): Requests a random number from the Native VRF by sending Ether along with the request.
- requestIds: Keeps track of the request IDs returned by the VRF.
- RandomGenerated: Emitted when a request is successfully made, logging the request ID.


## 3. Recording Random Results

After the random number is generated by the VRF contract, it can be recorded in your contract using the randomResults() function from the VRF interface. This function returns the generated random number for a specific request.

Here's an example of how to record the random number:

```solidity
function recordRandomResults() external {
    uint256 requestLen = requestIds.length;
    uint256 resultLen = randomResults.length;

    uint256 numResults = requestLen - resultLen;
    uint256[] memory results = new uint256[](numResults);

    for (uint256 i = 0; i < numResults; i++) {
        uint256 index = i + resultLen;
        uint256 reqId = requestIds[index];
        uint256 result = nativeVRF.randomResults(reqId);
        results[i] = result;
        emit RandomRecorded(index, result);
    }
}
```

### Notes:

- randomResults(): Retrieves the random number for each request ID.
- This function loops through all the pending requests and stores the results in randomResults.

## 4. Example Use Case

Here's how the entire process would look in your contract:

```solidity
// SPDX-License-Identifier: MIT
pragma solidity 0.8.4;

import "../interfaces/INativeVRF.sol";

contract NativeVRFConsumer {

    uint256[] public randomResults;
    uint256[] public requestIds;
    INativeVRF public nativeVRF;

    event RandomGenerated(uint256 indexed index, uint256 indexed requestId);
    event RandomRecorded(uint256 indexed index, uint256 indexed result);

    constructor(address nativeVRF_) {
        nativeVRF = INativeVRF(nativeVRF_);
    }

    // Function to request a random number
    function generateRandom() external payable {
        uint256[] memory ids = nativeVRF.requestRandom{value: msg.value}(1);
        requestIds.push(ids[0]);

        emit RandomGenerated(requestIds.length, ids[0]);
    }

    // Function to record random numbers
    function recordRandomResults() external {
        uint256 requestLen = requestIds.length;
        uint256 resultLen = randomResults.length;

        uint256 numResults = requestLen - resultLen;
        uint256[] memory results = new uint256[](numResults);

        for (uint256 i = 0; i < numResults; i++) {
            uint256 index = i + resultLen;
            uint256 reqId = requestIds[index];
            uint256 result = nativeVRF.randomResults(reqId);
            results[i] = result;
            emit RandomRecorded(index, result);
        }
    }
}
```

### Notes:

- You can customize the number of random numbers requested by adjusting the parameter in requestRandom().
- The msg.value must be set to cover the gas fees associated with the random number request.

## 5. Checking Transactions on the Blockchain Explorer

After requesting and recording a random number, you can track the transactions on the blockchain explorer:

- Request Transaction: <explorer_url>/tx/<request_tx_id>
- Result Recording Transaction: <explorer_url>/tx/<recording_tx_id>

## 6. Further Resources

For more details, visit the following resources:

GitHub Repository for Native VRF: [Native-VRF](https://github.com/Native-VRF/native-vrf)
GitHub Repository for Ripio's Native VRF: [verifiable-random-function](https://github.com/ripio/verifiable-random-function)
